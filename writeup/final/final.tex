%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt, oneside]{article} % A4 paper and 11pt font size
\usepackage[margin=1in]{geometry}
\geometry{letterpaper}

\usepackage{pslatex}
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}
\usepackage[]{hyperref}


\usepackage{sectsty} % Allows customizing section commands

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

%\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

\renewcommand{\c}[1]{\texttt{#1}}
\newcommand{\code}[1]{\c{#1}}
\newcommand\todo[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\teambb}{\c{bennyblum}}
\newcommand{\teamol}{\c{louisofir}}
\DeclareMathOperator{\MD}{MD}

%----------------------------------------------------------------------------------------
%   TITLE SECTION
%----------------------------------------------------------------------------------------

\title{ 
Tweetnet: Finding the bots of the flock\
}

\author{
Josh Blum (joshblum@mit.edu)\\
Bennet Cyphers (bcyphers@mit.edu)\\
Ofir Nachum (ofir@mit.edu)\\
Louis Sobel (sobel@mit.edu)\\
\\
6.857 Final Project
\date{\today}
}

\begin{document}

\maketitle

\vfill

\begin{abstract}
    Due to Twitter's scale, anonymity, and the reliability of its messenging
    service, it is an attractive platform for botnet command and control. The
    goal of our project was to examine how such a botnet might be implemented,
    and to determine whether botnets tweeting in the firehose can be detected
    efficiently. Our approach was to design a game which captures the essential
    elements of the botnet communication problem. In the game, each of two teams
    implements a botnet, and has a limited amount of time to send a random
    signal over a Twitter-like network; the goal is to do so without being
    detected by the other team, as well as to discover the details of the other
    team's botnet. We conducted two rounds of the game under different sets of
    rules. We found that an adversary who takes sufficient precautions with his
    or her design can communicate complex, arbitrary commands over Twitter
    in a way that is most likely infeasible to detect, even if the source code
    of the scheme is compromised.
    
\end{abstract}

\clearpage

\section {Introduction}
Botnets represent some of the most persistent threats on the internet today.
Over the past two decades, as the world wide web has grown into a massive,
unregulated platform for global commerce and innovation, so too has the use of
networks of hijacked computers for malicious purposes. A botnet, as such a
network is known, typically consists of a collection of machines infected with a
particular malware program, which allows them to covertly communicate with other
infected machines, perform their intended function, and act on commands issued
by a central operator. Botnet operators can leverage their armies of "zombies"
to distribute spam, spread malware, or execute targeted DDoS attacks. Most users
of infected computers do not know that they are compromised. 

A central aspect of botnet design is the "command and control" (C\&C) scheme:
the operator must be able to control infected machines in a reliable, scalable
manner, while avoiding detection and securing against intervention from
competing parties. At its core, C\&C requires a way to send messages to thousands
of machines in secret.

Twitter is an easy-to-use social media platform with a quick signup process, a
reliable distributed messenging service, and a robust API. In this project, we
looked at the use of Twitter as a platform for botnet command and control. Our
ultimate goal was to detect a botnet "in the wild," but along the way, we wanted
to determine how such a scheme might be designed, what challenges the
implementation would face, and what methods could be used to decect it. In order
to do so, we designed a game, split our group into two teams - \teambb{} and
\teamol{} - and competed to try to communicate a message from a 'master' to a
collection of "slaves" on a simplified model of Twitter. The result was
Tweetnet.

\section {Related Work}
Botnets using social networks for command and control are a relatively recent phenomenon. These botnets take advantage of the reliable infrastructure and easy-to-use APIs of social networks to communicate commands to infected computers. Several of these botnets have already been detected. 

Several botnets have been discovered in the wild \cite{arbor, trendmicro, flashback}. In 2009, Arbor Networks \cite{arbor} discovered a Twitter bot which periodically tweets base-64 encoded commands that specify URLs for downloading malicious binaries. The Mehika botnet \cite{trendmicro} is another botnet which was found utilizing Twitter to send commands to its botslaves. The Macintosh Flashware malware provides another example of a botnet using Twitter for command and control \cite{flashback}. The malware queries Twitter for tweets containing specific hashtags. 

In addition to these detected botnets, several groups have designed and implemented social networking botnets \cite{socialnetworking, trojan7, stegobot}. A group of San Jose University researchers design and implement their \emph{SocialNetworkingBot} to issue commands via Twitter for such things as browsing a URL, taking a screenshot, shutting down the computer, or changing botmaster \cite{socialnetworking}. Another notable example is a group of researches developing \emph{Stegobot}, a botnet which covertly communicates via JPEG stegonography of images shared on social networks. These examples highlight the ease in which it is possible to use social networks as botnet infrastructure.

In response the the growing threat of botnets using social networks, researchers have proposed several detection mechanisms to thwart such botnets \cite{botsniffer, kartaltepe, burghouwt}. Gu et al. propose an approach using network-based anomaly detection \cite{botsniffer}. These methods are useful when botnet activity is temporally correlated. Kartaltepe et al. present a content-specific method, proposing a classifier for classifying natural text from base-64 or otherwise encoded commands \cite{kartaltepe}. The group also suggests client-side detection mechanisms that are alerted by network traffic of dubious origin (for example, if a Twitter URL is requested when no browser actually has Twitter displayed).

The previous work in this field shows that, while botnets using social networks is a relatively recent phenomenon, the threat of even better concealed botnets is growing rapidly. For this reason, it is imperative that new detection mechanisms be devised.

\section{Game Overview}
	This section describes the simulaton of twitter we used in order to experiment with bot
	detection and development techniques.

	The twitter firehose, the stream of all tweets, is 
	thousands of tweets per second -- millions per day. Attempting to
	identify a botnet in this from scratch would be extraordinarily difficult.
	Instead, we decided to use a simulation of twitter and structure our
	project as a game.
	
	\subsection{Description}
		We planned on splitting up the four person group into two teams of two.
		Each team would take a turn designing a bot and using it to send information
		across twitter. The other team would use the tweet stream in order
		to try and figure out what the command and control protocol was
		and which twitter handle was the botmaster. The defending team
		would be able to pick what information was transferred, and would
		know all the tweets that were sent and by whom.

	\subsection{Justification}
		The use of a game model for security was a reasonable decision.
		First, it allow simulation of tactics at a small scale. The small
		scale allowed us to focus on strategy and cryptography, not
		dealing with twitter's massive amount of data. Second, there
		is precedent for such models of security, such as \textsf{IND-CCA},
		\textsf{IND-CCP}, and others. In these game models, an adversary
		is given generous capabilities, such as a ciphertext oracle.
		If a scheme is secure under these conditions, it can then
		be considered secure. Our choice of allowing the defending team
		to choose the information the bots need to transfer was guided
		by this precedent.

	\subsection{Infrastructure}
		We chose not to play our game actually using twitter.com's services,
		but rather to build a limited subset of them for ourselves. There were
		three reasons for this. First, we were worried about the ramifications
		of using automated twitter accounts on twitter, including ones
		that were designed for botnets.
		Second, some infrastructure would be needed for the game, such as
		keeping track of when information has been successfully transferred. Since some infrastructure
		would already be needed, it made sense to create a limited version of twitter as well.
		Finally, it made testing and using the bots much more effective. We didn't have
		to deal with millions of tweets, only those germane to our game.
		The infrastructure we built supports basic usernames and tweeting.
		The code is available \todo{here}.

	\subsection{Rules}
		Having given the background on our game, this section now gives a description
		of the initial rules.
		\begin{itemize}
		 \item There are two teams -- the attacking team and the defending team. The attacking
		 	team is trying to use twitter as a command an control channel, while the defending
			team is trying to catch them.
		 \item There are 10 twitter users - 9 \textit{benign} tweeters, who simulate regular people,
		 	and 1 username controlled by the attacking team.
		 \item The defending team randomly generate a \textit{flag}, which is is random 128 bit
			hexadecimal string
		 \item The attacking team must pass this flag to 10 \textit{bots}, using only twitter
		 	as the communication channel.
		\item When a bot receives a flag, it submits it to the defender as proof of the communication
		\end{itemize}

		For enforcement of the rules, we relied both on the infrastructure described above as well
		as on an implicit cooperative understanding between the same teams, who would not want to
		be labelled cheaters in a project.

% \section{Meet the Team}
% 	\subsection{Team Blumbenny}

% 	\begin{figure}
% 		\centering
% 		\begin{subfigure}{.4\textwidth}
% 			\centering
% 			\includegraphics[width=.4\textwidth]{resources/blum.jpg}
% 			\caption{Blum}
% 		\end{subfigure}
% 		\begin{subfigure}{.4\textwidth}
% 			\centering
% 			\includegraphics[width=.4\textwidth]{resources/benny.jpg}
% 			\caption{Benny}
% 		\end{subfigure}
% 		\caption{Team Blumbenny}
% 	\end{figure}


% 	\subsection{Team Lofir}
	
% 		\begin{figure}
% 		\centering
% 		\begin{subfigure}{.4\textwidth}
% 			\centering
% 			\includegraphics[width=.4\textwidth]{resources/louis.jpg}
% 			\caption{Louis}
% 		\end{subfigure}
% 		\begin{subfigure}{.4\textwidth}
% 			\centering
% 			\includegraphics[width=.4\textwidth]{resources/ofir.jpg}
% 			\caption{Ofir}
% 		\end{subfigure}
% 		\caption{Team Lofir}
% 	\end{figure}

\section{Round 1}
	This section describes the setup, designs, attacks, and takeaways from the first round of gameplay, where each team
	built a botmaster.

	\subsection{Setup}
		During the first round, each team designed a single \c{Bot} and \c{BotMaster} pair which had to submit a single flag. There were 10 unique handles used in the game pool, of which 1 was the botmaster and the other 9 being benign users, which would tweet with a $0.20$ probability each second. \teambb{}'s bots knew the botmaster handle at the beginning of the round whereas \teamol{}'s bots established the botmaster as part of their design. \\

		In this round bots were allowed to begin arbitrary secrets such as values for a random seed or cryptographic keys. The goal of this round was to allow the teams to familiarize themselves with the game infrastructure and begin building discovery techniques. For this reason, we allowed may simplifications to the game structure for this round, with the intent of modifying the game structure in the subsequent round. 

	\subsection{Designs}
		This section presents the designs for bots and botmasters implemented for round one.
	
		\subsubsection{\teambb{}}
			\teambb{} built the \c{SingelCharBotMaster} which relied on a \c{prng} to signify tweets which were information carrying. The botmaster and bots both shared a common seed value for the \c{prng}. The \c{prng} was also used to transfer a single character in each tweet that was information carrying. The character offset and value for which information tweets was used by each next random value. Figure \ref{fig:prng} shows an example of how the \c{prng} was used to offset information tweets, and figure \ref{fig:prng-tweet-ex} shows how this offset is used to store a character of the flag within a tweet. \\

		\begin{figure}[H]
		    \center\includegraphics[scale=0.70]{resources/prng.png}
		    \caption{An example of how the \c{SingleCharBotMaster} design uses a \c{prng} to offset which tweets carry information.}
		    \label{fig:prng}
		 \end{figure}

		 \begin{figure}[H]
		    \center\includegraphics[scale=0.60]{resources/prng-tweet-ex.png}
		    \caption{An example of how the \c{SingleCharBotMaster} design stores flag information in a information carrying tweet.}
		    \label{fig:prng-tweet-ex}
		 \end{figure}
		
			
		\subsubsection{\teamol{}}
			\teamol{} built the \c{SpaceBotmaster}. This botmaster used a space at the end of tweet text to signify a flag-relevant tweet. The master would insert a punctuation mark immediately preceding the space (`.', `,', `!', `?'), and this would provide two bits of the flag. There is also a special start-flag punctuation mark. 

			\teamol{} also put in capabilities for the master to identify itself discreetly. The master partitioned time to 12-second windows. When the master tweets randomly (when it did not have a flag to communicate), it would tweet only in the first 6 seconds of the 12-second window. This way, when the botslaves analyzed the tweets of users, they would notice the master has a significant amount of tweets in the first 6 seconds of every 12-second window. Any other benign user tweets oblivious to this 12-second window, and thus tweets equally in the first 6 seconds as in the last 6 seconds. In this way, the master is able to discreetly make itself aware to the botslaves.

	\subsection{Attacks}
		This section presents the attacks that were used on the designs of round one.

		\subsubsection{\teambb{}}
			The first step in analyzing the data from \teamol{} was to see if there were any inconsistencies from the data set that caused a particular handle to differentiate itself. Using the \c{json} Python module  and simple queries across the dataset, the botmaster handle was able to be identified since the frequency of tweeting was twice of any other handle. \\

			We looked at several techniques in order to identify the master before the handle was found, for example, looking at the frequency of different emoticons and any signal hashtags that may have been used. Once this handle was discovered, we wanted to dig deeper into reverse engineering the protocol used. \\

			Among the set of tweets from the suspect handle, the first thing that stuck out was that many of the tweets had a space character appended to the end of the tweet. This furthered the suspicion that the handle was the botmaster, and we believed that a binary string was being encoded based on whether the tweet had a space or not to signal a 1 or 0. \\

			Since we knew that the botmaster handle was not known to the bots initially, the botmaster would have had to been established and then 32 characters of the flag transfered. We tried various transformations of the binary string to convert it to the flag output, without success. 

		\subsubsection{\teamol{}}
	We were able to almost entirely discover \teambb{}'s design. We began with visual inspection of the collection of tweets,
	an we immediately noticed aberrations such as \code{r8ally}, \code{RTa@coolman123} -- patterns that did not look anything
	like what would normally appear on twitter. We further noticed that all of these strange aberrations came from the same
	username: \code{tweetnet01}.

	Then, we computed tweet frequency by username, and discovered that \code{tweetnet01} had tweeted almost twice as many times
	as the rest of the usernames had. This cemented our suspicion that \code{tweetnet01} was the botmaster. By visually inspecting
	all of \code{tweetnet01}'s tweets, with a highlighter and pen in hand, we were able to find an entire flag embedded in
	outlying tweets. By examining the pattern of flag character offset and gap between flag tweets, we further identified their
	pattern of $n$-down, $n$-over. We decided this was based on a PRNG, and did not pursue the seed any further.

	\subsection{Problems}
		From this round we discovered problems both with the game and bot design. \\

		The game used for this round was an inaccurate representation of Twitter. We allowed many assumptions, such as a very small user base, no social graph interactions, and access to the random tweet oracle. These simplifications allowed the attacking teams a great advantage when trying to analyze the bots. For example, any analysis that was done by hand would be unrealistic for the actual Twitter environment without large machine learning or crowd sourced infrastructure. \\ 
		
		The over arching problems with both bot designs is that the tweets that were generated by the botmaster did not allow it to blend in with other benign tweeters. This showed how difficult using steganography can be since neither team was able to mask the information they wished to hide within tweet effectively. These types of errors were coupled with implementation flaws such as failing to mask the flag content in the \c{SingleCharBotMaster} or mis-configuring the tweeting probability (0.5 was used instead of 0.05). \\

		We did learn, however, that a high throughput is not necessary to the success of a botmaster. Since many users tweet with a high frequency, even if each tweet from the botmaster relays less than a single bit, not much information is needed to transfer signals to the bots. For example, a botmaster could post a large amount of malicious (spam) content to a public service such as pastebin \cite{pastebin}, and simply use twitter to communicate the URL to the bots. \\


\section{Round 2}
	This section is a description of the events of the second round.

	\subsection{Modifications}
		The second round introduced several modifications to the game structure. First, the number of bot handles was increased to 20, 2 of which were botmasters. This allowed the pool of active handles to increase and to give the designs more flexibility in their protocol. \\

		The second major change was that the code of the bots was to be open sourced to the detection to see. The bots were allowed a configuration file with predefined constants, but all other code was going to be revealed. The motivation behind this was that botnets can be discovered and their source or binary de-obfuscated. The network would be robust to such an attack and the botmaster handle should be able to remain anonymous. \\

		
	\subsection{Designs}
        Perhaps due to the discussions we had following the results of the first round, the two bot schemes developed for the second round turned out 
		\subsubsection{\teambb{}}
        	In the second round, \teambb{} built the \c{HashPadBot}. This bot begins by generating a secret 32-character hex string (the pad) to mask the flag, and a single character (4-bit) start signal. The start character and the pad are generated using an instance of Python's Random object, seeded with a 32-bit secret shared among all bots in the network.
        	
            When the round starts, the botmaster tweets randomly until it receives the flag from the server. Upon receiving the flag, the botmaster sends the start character followed by the 32 characters of the flag XORed with the characters of the pad. Each masked character, $c_i$, is sent in one tweet, chosen at random from a precompiled library of legitimate tweets such that $c_i = \texttt{hash(tweet)} \pmod{16}$. The botmaster does not send any tweets which hash to the start character until the flag is received, and at all times the master tweets at the same frequency as the legitimate tweeters.
        	
            The listeners consume and discard tweets from the botmaster handle, which they know ahead of time, until one of them hashes to the precomputed start character. At this point, each listener consumes the next 32 tweets, decoding them to characters in the flag according to $f_i = \texttt{hash(tweet)} \pmod{16} \oplus p_i$, where $f_i$ is the $i^{th}$ character in the flag and $p_i$ is the $i^{th}$ character in the pad. Once all 33 tweets have been consumed, the listener can submit the flag at its leisure.
		\subsubsection{\teamol{}}
			\teamol{} built the \c{MD5HashBot}. When given a flag, one of the botmasters was chosen at random to communicate the flag. This botmaster first masked the flag via a synchronized pseudorandom number generator. This 32-digit masked flag along with a prepended 4-digit start signal is communicated one hex-digit at a time in the following way: The bot tweets a tweet with content $content$ such that
			\[
				d=\MD5(\MD5(content)\oplus S_k) \pmod{16},
			\] 
			where $d$ is the desired hex-digit and $S_k$ is a secret key included in the configuration file.

			To further hide the flag communication, the bot does not tweet these flag-relevant tweets in succession. Rather, it tweets between 0 and 4 superfluous tweets between each  flag-relevant tweet. The bot also tweets a certain number of superfluous tweets before beginnning flag communication. These numbers are determined by a synchronized psuedorandom number generator.

			To effectively imitate natural communication frequency, \teamol{} implemented a \c{TweetQueue}. Tweets are pushed onto the queue. A single process handles popping and tweeting items from the queue so that a tweet frequency emulating the benign tweeters is maintained.
	\subsection{Attacks}
		This section presents the attacks that were used by the various teams on the round 2 designs.

		\subsubsection{\teambb{}}

		\subsubsection{\teamol{}}
			With \teambb{}'s code in hand, we were able to identify several coding errors and vulnerabilities:  
			\begin{enumerate}
				\item To generate a random 128-bit integer, \c{HashPadBot} generates a random float and then multiplies it by $2^{128}$.  However, floats only provide 32 bits of precision.  This means that a significant portion of the flag is communicated unmasked.
				\item \c{HashPadBot} uses a single-digit start signal.  This start signal is generated by the faulty random number generator, causing it to always be $0$.
				\item \c{HashPadBot} was intended to tweet with a certain probability every second.  This was implemented incorrectly when the bot was not communicating a flag.  At these times, the bot was tweeting with a certain probability every \emph{other} second.
				\item \c{HashPadBot} immediately and serially communicates the flag as soon as it obtains it.  Similarly, the botslaves immediately submit it as soon as they decipher it.
				\item \c{HashPadBot} does not use a cryptographic hash function but rather Python's built-in \c{hash} function.  This hash function is not pseudorandom and actually very malleable (for example, the hash of ``hello'' is $840651671246116861$ and the hash of ``helli'' is $840651671246116859$).
			\end{enumerate}
			Due to vulnerability (2) \teamol{} was able to narrow down the search to tweeters which only tweeted a tweet whose hash yields a `0' start signal after the first flag.  Subsequently, \teamol{} looked at the 32 tweets following the start signal, and exploited vulnerability (1) to find the partially unmasked flag.  This showed \c{tweetnet16} to be the only candidate botmaster.  This was confirmed via vulnerability (3): \c{tweetnet16} had the lowest number of tweets in the period when there was no flag to be communicated.  \teamol{} was even able to successfully brute-force a search for the randomization seed, which definitively identified \c{tweetnet16} as the botmaster.

			The other vulnerabilities were not used to find the botmaster.  However, given a larger collection of tweets to analyze or more adverse conditions for the detection team, these vulnerabilities could have been exploited to better detect botnet activity.

	\subsection{Problems}
		The main problem that undermined the botnet designs in this round were not protocol designs, but rather coding errors.
		These are still valid issues to discuss, as actual implementation of a protocol is an important part of applied security.
		\teambb{} was undermined by an incomplete understanding of the python numerical model. Errors with under and overflow
		are a very common source of bugs. Additionally, both teams put too much faith in the default python PRNG. It can easily
		be brute forced. The number of bits in its seed is only 32 -- even when a python \code{long} is used as the seed, python
		internally uses the hash value of that long, which is only 32 bits. These issues are implementation issues, not protocol
		ones. Mistakes like these are a common source of security issues, and it is possible that python is not a suitable language
		for designing cryptographic protocols.

\section{Discussion}
	This section presents a discussion of the results above. We discuss what we learned, the applicability of our project
	to the real twitter.com, and possible future work.

	\subsection{What we learned}
		Through our iterative game, we are able to realize the challenges faced by botnet designers and botnet detection teams. 

		First, we realize that tweet frequency is a key aspect of any botnet and can often be a botnet's most vulnerable component. In the first round of gameplay, we see that both teams were unsuccessful at achieving a natural tweet frequency. This single flaw was easily visible to bot detection teams, and made identifying the botmaster easy. In the second round, we see that even with the lessons of the first round learned, \teambb{} make mistakes which lead to detectable and unnatural tweet frequencies. This shows that making frequency of communication natural is a key goal for designers of botnets using social networks. Although this is a feasible goal, it is very easy to get wrong. From the botnet detection perspective, characterizations of natural communication frequency and tools to detect deviations from this frequency are some of the most useful for detection teams. 

		Another key aspect is natural tweet content. In round 1, both teams used communication methods that altered tweet text. These methods were then easily detected during the detection phase. This shows that even seemingly concealing communication tactics that change natural text(like single character alterations) can be easily detected. However, botnet designers can thwart this by using the hashing method used by both teams in round 2. Despite this work around, it is still very important for detection teams to have a tool for distinguishing natural from unnatural text, as many bot designer may overlook this vulnerability.

	\subsection{How this extends to real twitter}
	Some of what we've learned with regard to detecting and creating command and control over our simulated twitter can be applied to the
	actual twitter service. One thing is the ease of hiding information in a tweet by using the hash of a randomly generated, realistic looking tweet.
	This technique could definitely be used to send significant amounts of information, covertly. Another thing we learned that does extend to real
	twitter is that for a botnet to be successful, it would not need to transfer large amounts of data over the command and control channel. The order of
	bytes is sufficient to serve as a pointer to further instructions for the botnet. Twitter may be just one component of an elaborate command and control scheme.

	\subsection{How this does \textit{not} extend to real twitter}
    A related problem, which has plagued Twitter since its inception, is that of spambots. Spambots are computer-controlled twitter handles which tweet out ads, links, and otherwise annoying messages on behalf of a company or anonymous mischief maker. Spam detection is difficult. Several papers have been written on techniques for identifying these bots among the massive datasets that twitter produces \cite{botdetect} \cite{spambotML} \cite{socialnet_spam}, but as detection techniques advance, spambots evolve to compensate. Furthermore, since the goal of spambots is to send information for human consumption, they are restricted to messages in plain text or URLs. Botnets using Twitter are not hampered by such limitations. As we have demonstrated, information can be carried by sequences of arbitrary tweets using hashing, so a bot master only needs a sufficiently sized library of legitimate-sounding tweets to be able to transmit any possible message. Therefore, it seems likely that any botnet with sufficiently motivated operators can evade automated bot detection comparatively easily.

	\subsection{Future Designs / work}
        A related problem, which has plagued Twitter since its inception, is that of spambots. Spambots are computer-controlled twitter handles which tweet out ads, links, and otherwise annoying messages on behalf of a company or anonymous mischief maker. Spam detection is difficult. Several papers have been written on techniques for identifying these bots among the massive datasets that twitter produces, but as detection techniques advance, spambots evolve to compensate. Furthermore, since the goal of spambots is to send information for human consumption, they are restricted to messages in plain text or URLs. Botnets using Twitter are not hampered by such limitations. As we have demonstrated, information can be carried by sequences of arbitrary tweets using hashing, so a bot master only needs a sufficiently sized library of legitimate-sounding tweets to be able to transmit any possible message. Therefore, it seems likely that any botnet with sufficiently motivated operators can evade automated bot detection comparatively easily.
        
        In our tests, there were a small number of handles providing background noise in a very predictible fashion. This made it easy to look for subtle variations in timing and aggregate content in each handle's tweets, and to perform extensive analysis on every one. The real Twitter stream consists of millions of handles with wildly varying tweet patterns in several languages, so it is much more difficult to identify breaks from general trends. For example, \teambb{}'s botmaster in round 2 was identified in part because it tweeted half as frequently as normal handles; in reality, the normal range of tweet frequency spans orders of magnitude (anywhere from several times an hour to once or twice a year), so it would be infeasible to use this metric alone to filter out bots. In addition, it is computationally infeasible to analyze any significant fraction of the firehose at the level of detail that we were able to. 
        \subsection{Future Designs / work}

        The current mock Twitter infrastructure could be extended to modify the gameplay and make the simulation more realistic. Some aspects of gameplay were never explored, such as analyzing the social graph through followers, or having a distribution of benign user behavior. Modifying these part of the infrastructure would change how the detecting teams could perform their analysis and move the detection closer to what it would be like when using real tweets. \\

		Another feature that could be extended is the access of a tweet oracle to the botmaster. This assumption allowed the botmaster to generate realistic tweets on demand, an ability which is quite complicated in real life. Forcing botmasters to develop their own tweets (or only retweet other users) would make the job of the botmaster much more difficult, but also face a challenge that a botnet would face if they wished to hide their command and control within Twitter.


\section{Conclusion}

        Botnets are bad, mkay?


\clearpage
\section{References}

\begingroup
\renewcommand{\section}[2]{}%
\begin{thebibliography}{99}

\bibitem{arbor}
	\url{http://www.arbornetworks.com/asert/2009/08/twitter-based-botnet-command-channel/}

\bibitem{trendmicro}
	\url{http://www.trendmicro.com/cloud-content/us/pdfs/security-intelligence/white-papers/wp_discerning-relationships__mexican-botnet.pdf}

\bibitem{cryptome}
	\url{http://cryptome.org/2014/03/massive-twitter-botnet.htm}

\bibitem{socialnetworking}
	\url{http://www.mecs-press.org/ijcnis/ijcnis-v5-n6/IJCNIS-V5-N6-2.pdf}

\bibitem{trojan7}
	\url{http://trojan7malware.blogspot.com/2013/06/botnet-using-twitter-as-c.html}

\bibitem{flashback}
	\url{http://www.intego.com/mac-security-blog/flashback-mac-malware\%2Duses-twitter-as-command-and-control-center/}

\bibitem{botsniffer}
	\url{http://corescholar.libraries.wright.edu/cgi/viewcontent.cgi?article=1006&context=cse}

\bibitem{kartaltepe}
	\url{http://link.springer.com/chapter/10.1007/978-3-642-13708-2_30}

\bibitem{burghouwt}
	\url{http://link.springer.com/chapter/10.1007/978-3-642-25560-1_9}

\bibitem{botnet_survey}
	\url{http://www.sciencedirect.com/science/article/pii/S1389128612003568#}

\bibitem{stegobot}
	\url{http://www.cs.utexas.edu/~amir/papers/IH11-Stegobot.pdf}

\bibitem{skype}
	\url{http://link.springer.com/chapter/10.1007\%2F978-3-642-14215-4_5}

\bibitem{pastebin}
	\url{http://pastebin.com/}

\bibitem{botdetect}
    \url{http://www.cs.wm.edu/~hnw/paper/tdsc12b.pdf}

\bibitem{spambotML}
    \url{http://personal.psu.edu/students/h/x/hxw164/files/DBSec2010_Wang.pdf}

\bibitem{socialnet_spam}
    \url{http://www.cse.fau.edu/~xqzhu/courses/Resources/GSC.acsac10-socialnets.pdf}

\end{thebibliography}

\endgroup

\end{document}



